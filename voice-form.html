<!DOCTYPE html>
<html>
<head>
    <title>Voice Recognition Form</title>
    <meta charset="UTF-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f5f5f5;
            margin: 0;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        
        .form-group {
            margin-bottom: 25px;
            position: relative;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }
        
        input[type="text"],
        input[type="email"],
        textarea {
            width: 100%;
            padding: 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
            transition: border-color 0.3s;
        }
        
        input:focus,
        textarea:focus {
            border-color: #4d90fe;
            outline: none;
        }
        
        .active-field {
            border: 2px solid #4CAF50 !important;
            background-color: #f0fff0;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        button {
            padding: 10px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        
        .start-btn {
            background-color: #4CAF50;
            color: white;
        }
        
        .stop-btn {
            background-color: #f44336;
            color: white;
        }
        
        .next-btn {
            background-color: #2196F3;
            color: white;
        }
        
        button:hover {
            opacity: 0.9;
        }
        
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        .status-box {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-height: 100px;
            background-color: #333;
            color: white;
        }
        
        .yellow {
            color: yellow;
        }
        
        .cyan {
            color: cyan;
        }
        
        .recording-indicator {
            position: absolute;
            right: 10px;
            top: 40px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #f44336;
            display: none;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        
        .recording .recording-indicator {
            display: block;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Voice Recognition Form</h1>
        
        <form id="voiceForm">
            <div class="form-group" id="nameGroup">
                <label for="name">Name:</label>
                <input type="text" id="name" name="name" required>
                <div class="recording-indicator"></div>
            </div>
            
            <div class="form-group" id="addressGroup">
                <label for="address">Address:</label>
                <textarea id="address" name="address" rows="3" required></textarea>
                <div class="recording-indicator"></div>
            </div>
            
            <div class="form-group" id="emailGroup">
                <label for="email">Email:</label>
                <input type="email" id="email" name="email" required>
                <div class="recording-indicator"></div>
            </div>
            
            <div class="form-group" id="phoneGroup">
                <label for="phone">Contact Number:</label>
                <input type="text" id="phone" name="phone" required>
                <div class="recording-indicator"></div>
            </div>
            
            <div class="button-group">
                <button type="button" id="startRecording" class="start-btn">Start Recording</button>
                <button type="button" id="stopRecording" class="stop-btn" disabled>Stop Recording</button>
                <button type="button" id="lookGood" class="next-btn">Looks Good (Next Field)</button>
            </div>
            
            <div class="status-box">
                <h3>Recognition Status:</h3>
                <div id="textDisplay"></div>
                <p id="confirmationMessage">Was this correctly recognized?</p>
            </div>
        </form>
    </div>
    
    <script>
        // WebSocket and recording logic
        let socket = null;
        let displayDiv = document.getElementById('textDisplay');
        let server_available = false;
        let mic_available = false;
        let fullSentences = [];
        let mediaRecorder;
        let audioChunks = [];
        let stream;
        let isRecording = false;
        let activeFieldId = 'name'; // Default active field
        const serverCheckInterval = 5000; // Check every 5 seconds
        const formFields = ['name', 'address', 'email', 'phone'];
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 5;

        // Set initial active field
        document.getElementById(activeFieldId).classList.add('active-field');
        document.getElementById(activeFieldId + 'Group').classList.add('recording');

        function connectToServer() {
            // Close existing connection if any
            if (socket) {
                try {
                    socket.close();
                } catch (e) {
                    console.error("Error closing existing socket:", e);
                }
            }
            
            try {
                socket = new WebSocket("ws://localhost:8001");
                
                socket.onopen = function(event) {
                    server_available = true;
                    reconnectAttempts = 0;
                    updateStatus("Server connected");
                    console.log("WebSocket connection established");
                };
                
                socket.onmessage = function(event) {
                    try {
                        let data = JSON.parse(event.data);
                        if (data.type === 'fullSentence') {
                            fullSentences.push(data.text);
                            updateActiveFieldWithRecognition(data.text);
                            displayRealtimeText("", displayDiv);
                            document.getElementById('confirmationMessage').textContent = 
                                `Was this correctly recognized? (RTF: ${data.rtf.toFixed(2)})`;
                            console.log("Received transcription:", data.text);
                        } else if (data.type === 'error') {
                            updateStatus(`Error: ${data.message}`);
                            console.error("Server error:", data.message);
                        }
                    } catch (e) {
                        console.error("Error processing message:", e, event.data);
                    }
                };
                
                socket.onclose = function(event) {
                    server_available = false;
                    console.log("WebSocket connection closed:", event.code, event.reason);
                    updateStatus("Server disconnected");
                    
                    // If we were recording, stop
                    if (isRecording) {
                        stopRecording();
                    }
                    
                    // Try to reconnect if not closing cleanly
                    if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts++;
                        console.log(`Connection closed. Attempting to reconnect (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
                        setTimeout(connectToServer, 2000); // Wait 2 seconds before reconnecting
                    }
                };
                
                socket.onerror = function(error) {
                    console.error("WebSocket error:", error);
                };
            } catch (e) {
                console.error("Error creating WebSocket:", e);
                server_available = false;
            }
        }

        function displayRealtimeText(realtimeText, displayDiv) {
            let displayedText = fullSentences.map((sentence, index) => {
                return `<span class="${index % 2 === 0 ? 'yellow' : 'cyan'}">${sentence} </span>`;
            }).join('') + realtimeText;
            displayDiv.innerHTML = displayedText;
        }

        function updateStatus(message) {
            console.log("Status update:", message);
            if (!mic_available)
                displayRealtimeText("ðŸŽ¤ Please allow microphone access ðŸŽ¤", displayDiv);
            else if (!server_available)
                displayRealtimeText("ðŸ–¥ï¸ Please start the recognition server ðŸ–¥ï¸", displayDiv);
            else if (message)
                displayRealtimeText(message, displayDiv);
        }

        function updateActiveFieldWithRecognition(text) {
            const activeField = document.getElementById(activeFieldId);
            if (activeField) {
                activeField.value = text; // Replace mode
            }
        }

        function startRecording() {
            console.log("Attempting to start recording");
            if (!mic_available) {
                alert("Microphone access is not available. Please check your browser permissions.");
                return;
            }
            
            if (!server_available) {
                alert("Server connection is not available. Please ensure the ASR server is running.");
                return;
            }
            
            if (isRecording) {
                console.log("Already recording, ignoring start request");
                return;
            }
            
            isRecording = true;
            document.getElementById('startRecording').disabled = true;
            document.getElementById('stopRecording').disabled = false;
            fullSentences = [];
            audioChunks = [];
            displayRealtimeText("Listening...", displayDiv);
            document.getElementById(activeFieldId + 'Group').classList.add('recording');

            if (stream) {
                startAudioProcessing();
            } else {
                console.log("Requesting microphone access");
                navigator.mediaDevices.getUserMedia({ audio: true })
                    .then(str => {
                        console.log("Microphone access granted");
                        stream = str;
                        mic_available = true;
                        startAudioProcessing();
                    })
                    .catch(e => {
                        console.error("Error getting audio stream:", e);
                        updateStatus("Failed to access microphone");
                        isRecording = false;
                        document.getElementById('startRecording').disabled = false;
                        document.getElementById('stopRecording').disabled = true;
                    });
            }
        }

        function startAudioProcessing() {
            console.log("Starting audio processing");
            try {
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
                
                mediaRecorder.ondataavailable = function(e) {
                    if (e.data.size > 0) {
                        audioChunks.push(e.data);
                    }
                };
                
                mediaRecorder.onerror = function(e) {
                    console.error("MediaRecorder error:", e);
                };
                
                mediaRecorder.start();
                console.log("MediaRecorder started");
            } catch (e) {
                console.error("Error starting MediaRecorder:", e);
                updateStatus("Failed to start recording");
                isRecording = false;
                document.getElementById('startRecording').disabled = false;
                document.getElementById('stopRecording').disabled = true;
            }
        }

        function stopRecording() {
            console.log("Stopping recording");
            if (!isRecording) {
                console.log("Not recording, ignoring stop request");
                return;
            }
            
            isRecording = false;
            document.getElementById('startRecording').disabled = false;
            document.getElementById('stopRecording').disabled = true;
            document.getElementById(activeFieldId + 'Group').classList.remove('recording');

            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                try {
                    mediaRecorder.stop();
                    console.log("MediaRecorder stopped");
                    
                    mediaRecorder.onstop = function() {
                        console.log("Processing recorded audio chunks:", audioChunks.length);
                        if (audioChunks.length === 0) {
                            updateStatus("No audio recorded");
                            return;
                        }
                        
                        createWavFile(audioChunks, (wavBlob) => {
                            if (socket && socket.readyState === WebSocket.OPEN) {
                                console.log("Sending audio to server");
                                socket.send(wavBlob);
                                displayRealtimeText("Processing audio...", displayDiv);
                            } else {
                                console.error("Cannot send audio: WebSocket not open");
                                updateStatus("Cannot send audio: Server not connected. Attempting to reconnect...");
                                connectToServer();
                            }
                        });
                    };
                } catch (e) {
                    console.error("Error stopping MediaRecorder:", e);
                }
            } else {
                console.log("MediaRecorder not available or already inactive");
            }
        }

        function createWavFile(chunks, callback) {
            console.log("Creating WAV file from chunks");
            try {
                const blob = new Blob(chunks, { type: 'audio/webm' });
                const audioContext = new AudioContext();
                
                blob.arrayBuffer().then(arrayBuffer => {
                    console.log("Decoding audio data");
                    audioContext.decodeAudioData(arrayBuffer, (audioBuffer) => {
                        console.log("Audio data decoded successfully");
                        const wavBuffer = audioBufferToWav(audioBuffer);
                        const wavBlob = new Blob([wavBuffer], { type: 'audio/wav' });
                        callback(wavBlob);
                    }, (e) => {
                        console.error("Error decoding audio data:", e);
                        updateStatus("Failed to process audio");
                    });
                }).catch(e => {
                    console.error("Error converting blob to array buffer:", e);
                    updateStatus("Failed to process audio");
                });
            } catch (e) {
                console.error("Error creating WAV file:", e);
                updateStatus("Failed to create audio file");
            }
        }

        function audioBufferToWav(audioBuffer) {
            const numChannels = audioBuffer.numberOfChannels;
            const sampleRate = audioBuffer.sampleRate;
            const length = audioBuffer.length * numChannels * 2 + 44;
            const buffer = new ArrayBuffer(length);
            const view = new DataView(buffer);

            // WAV header
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + audioBuffer.length * numChannels * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true); // PCM format
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * 2, true);
            view.setUint16(32, numChannels * 2, true);
            view.setUint16(34, 16, true); // Bits per sample
            writeString(view, 36, 'data');
            view.setUint32(40, audioBuffer.length * numChannels * 2, true);

            // Audio data
            let offset = 44;
            for (let i = 0; i < audioBuffer.length; i++) {
                for (let channel = 0; channel < numChannels; channel++) {
                    const sample = audioBuffer.getChannelData(channel)[i];
                    const value = Math.max(-1, Math.min(1, sample)) * 32767;
                    view.setInt16(offset, value, true);
                    offset += 2;
                }
            }

            return buffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function moveToNextField() {
            console.log("Moving to next field from", activeFieldId);
            document.getElementById(activeFieldId).classList.remove('active-field');
            document.getElementById(activeFieldId + 'Group').classList.remove('recording');
            const currentIndex = formFields.indexOf(activeFieldId);
            if (currentIndex < formFields.length - 1) {
                activeFieldId = formFields[currentIndex + 1];
            } else {
                activeFieldId = formFields[0];
            }
            document.getElementById(activeFieldId).classList.add('active-field');
            if (isRecording) {
                document.getElementById(activeFieldId + 'Group').classList.add('recording');
            }
            document.getElementById(activeFieldId).focus();
            fullSentences = [];
            displayRealtimeText(`Now recording for ${activeFieldId}...`, displayDiv);
            document.getElementById('confirmationMessage').textContent = "";
            console.log("New active field:", activeFieldId);
        }

        // Initial setup
        console.log("Initializing application");
        connectToServer();

        // Request microphone access
        console.log("Requesting initial microphone access");
        navigator.mediaDevices.getUserMedia({ audio: true })
            .then(str => {
                stream = str;
                mic_available = true;
                console.log("Microphone access granted during initialization");
                updateStatus("Microphone access granted. Ready to start recording.");
            })
            .catch(e => {
                console.error("Error getting audio stream during initialization:", e);
                updateStatus("Failed to access microphone. Please check your settings.");
            });

        // Setup periodic server connection check
        setInterval(() => {
            if (!server_available) {
                console.log("Server check: not connected, attempting to connect");
                connectToServer();
            }
        }, serverCheckInterval);

        // Event listeners
        document.getElementById('startRecording').addEventListener('click', startRecording);
        document.getElementById('stopRecording').addEventListener('click', stopRecording);
        document.getElementById('lookGood').addEventListener('click', moveToNextField);
        document.getElementById('voiceForm').addEventListener('submit', function(e) {
            e.preventDefault();
            console.log("Form submission prevented");
        });
    </script>
</body>
</html>